import { IAuthService } from "../interfaces/iAuthService";
import IUserRepository from "../interfaces/iUserRepository";
import INotificationRepository from "../interfaces/iNotificationRepository";
import User from "../../domain/entities/user";
import Notification from "../../domain/entities/notification";
import { UserCredential } from "firebase/auth";

export class UserUseCases {
  constructor(
    private authService: IAuthService,
    private userRepository: IUserRepository,
    private notificationRepository: INotificationRepository
  ) {}

  async registerUser(
    email: string,
    password: string,
    username: string
  ): Promise<User> {
    try {
      // 1. Register in Firebase Auth
      const userCredential: UserCredential = await this.authService.register(
        email,
        password
      );
      const uid = userCredential.user.uid;

      // 2. Create User Entity
      const newUser: User = {
        id: uid,
        username: username,
        email: email,
        password: "", // Don't store password in the database
        isOnline: true,
        friends: [],
        friendRequests: [],
        outgoingFriendRequests: [],
      };

      // 3. Save to Repository
      await this.userRepository.createUser(newUser);

      return newUser;
    } catch (error) {
      console.error("Error in registerUser use case:", error);
      throw error;
    }
  }

  async loginUser(email: string, password: string): Promise<User | null> {
    try {
      // 1. Login with Firebase Auth
      const userCredential = await this.authService.login(email, password);
      const uid = userCredential.user.uid;

      // 2. Retrieve User Profile
      const user = await this.userRepository.getUserById(uid);

      return user;
    } catch (error) {
      console.error("Error in loginUser use case:", error);
      throw error;
    }
  }

  async logoutUser(): Promise<void> {
    try {
      const uid = this.authService.getCurrentUserId();
      if (uid) {
        // Explicitly set offline status before logging out
        const user = await this.userRepository.getUserById(uid);
        if (user) {
          await this.userRepository.updateUser({ ...user, isOnline: false });
        }
      }
      await this.authService.logout();
    } catch (error) {
      console.error("Error in logoutUser use case:", error);
      throw error;
    }
  }

  async getCurrentUser(): Promise<User | null> {
    try {
      const uid = this.authService.getCurrentUserId();
      if (!uid) return null;
      return await this.userRepository.getUserById(uid);
    } catch (error) {
      console.error("Error getting current user:", error);
      return null;
    }
  }

  async getAllUsers(): Promise<User[]> {
    try {
      return await this.userRepository.getAllUsers();
    } catch (error) {
      console.error("Error getting all users:", error);
      return [];
    }
  }

  async getUserById(id: string): Promise<User | null> {
    try {
      return await this.userRepository.getUserById(id);
    } catch (error) {
      console.error("Error getting user by id:", error);
      return null;
    }
  }

  async sendFriendRequest(fromUserId: string, toUserId: string): Promise<void> {
    try {
      const toUser = await this.userRepository.getUserById(toUserId);
      const fromUser = await this.userRepository.getUserById(fromUserId);

      if (!toUser || !fromUser) throw new Error("User not found");

      // Check if already friends
      if (toUser.friends?.includes(fromUserId)) {
        throw new Error("Already friends");
      }

      // Check if request already sent by fromUser to toUser
      if (toUser.friendRequests?.includes(fromUserId)) {
        throw new Error("Friend request already sent");
      }
      // Also check from the sender's side
      if (fromUser.outgoingFriendRequests?.includes(toUserId)) {
        throw new Error("Friend request already sent by you");
      }

      // Add to recipient's friendRequests list (incoming)
      const updatedIncomingRequests = toUser.friendRequests
        ? [...toUser.friendRequests, fromUserId]
        : [fromUserId];
      const updatedToUser = {
        ...toUser,
        friendRequests: updatedIncomingRequests,
      };
      await this.userRepository.updateUser(updatedToUser);

      // Add to sender's outgoingFriendRequests list
      const updatedOutgoingRequests = fromUser.outgoingFriendRequests
        ? [...fromUser.outgoingFriendRequests, toUserId]
        : [toUserId];
      const updatedFromUser = {
        ...fromUser,
        outgoingFriendRequests: updatedOutgoingRequests,
      };
      await this.userRepository.updateUser(updatedFromUser);

      // Create Notification
      const notification: Notification = {
        id: "", // generated by repo
        recipientId: toUserId,
        senderId: fromUserId,
        type: "FRIEND_REQUEST",
        isRead: false,
        createdAt: Date.now(),
        data: {
          username: fromUser.username,
        },
      };

      await this.notificationRepository.createNotification(notification);
    } catch (error) {
      console.error("Error sending friend request:", error);
      throw error;
    }
  }

  async acceptFriendRequest(
    currentUserId: string,
    requesterId: string,
    notificationId: string
  ): Promise<void> {
    try {
      const currentUser = await this.userRepository.getUserById(currentUserId);
      const requester = await this.userRepository.getUserById(requesterId);

      if (!currentUser || !requester) throw new Error("User not found");

      // Add to friends list for both
      const currentUserFriends = currentUser.friends
        ? [...currentUser.friends, requesterId]
        : [requesterId];
      // Remove from incoming requests
      const currentUserRequests = currentUser.friendRequests
        ? currentUser.friendRequests.filter((id) => id !== requesterId)
        : [];
      // Remove from outgoing requests if any (e.g. mutual request sent at same time)
      const currentUserOutgoingRequests = currentUser.outgoingFriendRequests
        ? currentUser.outgoingFriendRequests.filter((id) => id !== requesterId)
        : [];

      const updatedCurrentUser = {
        ...currentUser,
        friends: currentUserFriends,
        friendRequests: currentUserRequests,
        outgoingFriendRequests: currentUserOutgoingRequests,
      };
      await this.userRepository.updateUser(updatedCurrentUser);

      const requesterFriends = requester.friends
        ? [...requester.friends, currentUserId]
        : [currentUserId];
      // Remove from outgoing requests for requester (as it's now accepted)
      const requesterOutgoingRequests = requester.outgoingFriendRequests
        ? requester.outgoingFriendRequests.filter((id) => id !== currentUserId)
        : [];

      const updatedRequester = {
        ...requester,
        friends: requesterFriends,
        outgoingFriendRequests: requesterOutgoingRequests,
      };
      await this.userRepository.updateUser(updatedRequester);

      // Mark notification as read (or delete it)
      await this.notificationRepository.markAsRead(
        currentUserId,
        notificationId
      );

      // Send acceptance notification to requester
      const notification: Notification = {
        id: "",
        recipientId: requesterId,
        senderId: currentUserId,
        type: "FRIEND_REQUEST_ACCEPTED",
        isRead: false,
        createdAt: Date.now(),
        data: {
          username: currentUser.username,
        },
      };
      await this.notificationRepository.createNotification(notification);
    } catch (error) {
      console.error("Error accepting friend request:", error);
      throw error;
    }
  }

  async rejectFriendRequest(
    currentUserId: string,
    requesterId: string,
    notificationId: string
  ): Promise<void> {
    try {
      const currentUser = await this.userRepository.getUserById(currentUserId);
      if (!currentUser) throw new Error("User not found");

      // Remove from incoming requests
      const currentUserRequests = currentUser.friendRequests
        ? currentUser.friendRequests.filter((id) => id !== requesterId)
        : [];

      const updatedCurrentUser = {
        ...currentUser,
        friendRequests: currentUserRequests,
      };
      await this.userRepository.updateUser(updatedCurrentUser);

      // Mark notification as read or delete
      await this.notificationRepository.markAsRead(
        currentUserId,
        notificationId
      );
    } catch (error) {
      console.error("Error rejecting friend request:", error);
      throw error;
    }
  }

  async getNotifications(userId: string): Promise<Notification[]> {
    try {
      return await this.notificationRepository.getNotificationsForUser(userId);
    } catch (error) {
      console.error("Error getting notifications:", error);
      return [];
    }
  }

  async searchUsers(query: string): Promise<User[]> {
    try {
      const users = await this.userRepository.getAllUsers();
      const lowerQuery = query.toLowerCase();
      return users.filter(
        (user) =>
          user.username.toLowerCase().includes(lowerQuery) ||
          user.email.toLowerCase().includes(lowerQuery)
      );
    } catch (error) {
      console.error("Error searching users:", error);
      return [];
    }
  }

  async searchFriendsOfUser(userId: string, query: string): Promise<User[]> {
    try {
      const friends = await this.userRepository.getFriendsOfUser(userId);
      const lowerQuery = query.toLowerCase();
      return friends.filter(
        (friend) =>
          friend.username.toLowerCase().includes(lowerQuery) ||
          friend.email.toLowerCase().includes(lowerQuery)
      );
    } catch (error) {
      console.error("Error searching friends:", error);
      return [];
    }
  }

  initializeUserPresence(userId: string): void {
    try {
      this.userRepository.initializePresence(userId);
    } catch (error) {
      console.error("Error initializing user presence:", error);
    }
  }

  subscribeToFriends(
    userId: string,
    callback: (friends: User[]) => void
  ): () => void {
    try {
      return this.userRepository.subscribeToFriends(userId, callback);
    } catch (error) {
      console.error("Error subscribing to friends:", error);
      return () => {};
    }
  }

  subscribeToUser(
    userId: string,
    callback: (user: User | null) => void
  ): () => void {
    try {
      return this.userRepository.subscribeToUser(userId, callback);
    } catch (error) {
      console.error("Error subscribing to user:", error);
      return () => {};
    }
  }
}
